ALPHABET = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\
                'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\
                'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')
# масив символів, які ми будемо шифрувати (символи які не входять в масив ми шифрувати не будемо)

ORIGINAL_WORD = "Test" #це слово, яке ми будемо шифрувати
#текст (строка) схожа на масив, де кожен елемент - нова буква

KEY = 3 #це ключ шифрування, на цю кількість позицій, ми будемо зсувати кожну букву

crypted_word = list(ORIGINAL_WORD) #створюємо список зі строки.
#строку(масив літер) ми змінити не можемо (це правило), а кожен елемент/букву списку - можемо


#ВАЖЛИВО: Всі строчки коду написані до цього виконуються одна за одною, коли ми запускаємо програму
#функції (як та, яка написана нижче) читаються в пам’ять, але не виконуються, вони
#виконаються лише тоді, коли ми їх викличемл (не викличемо - не виконаються)

def crypt(word, key, crypt):
    #word - слово, з яким будемо працювати
    #key - ключ, ми можемо використати той, який вже є (KEY), але для прикладу ми його передамо
    #crypt - містить True, якщо ми шифруємо і  False, якщо розшифровуємо
    if not crypt:
        key = -key #ми це вже робили, ключ від’ємний, якщо ми розшифровуємо
        print("key changed to negative")
    print("key=" + str(key))
    
    for i in range(len(word)): #зверніть увагу, беремо довжину слова, яке передаємо
        letter = word[i] 
        index = ALPHABET.index(letter) 
        new_index = index + key
        word[i] = ALPHABET[new_index] 
        print("word = " + str(crypted_word))

#тут без табуляції, тобто це код вже не відноситься до функції
#відповідно тут ми викличемо вже описані нами функції

print("encrypt")
crypt(crypted_word, KEY, True) #викликали функцію для зашифрування, і передали потрібні аргументи

print("decrypt")
crypt(crypted_word, KEY, False) #викликаємо для розшифрування
#зверніть увагу, що змінна crypted_word вже містить зашифроване слово
